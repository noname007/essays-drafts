---
layout: post
title:  "补码，用一个圆盘理解"
date:   2012-12-17 17:55:48 +0800
categories: 随笔
published: true
---

计算机内部执行的指令都是以补码的形式进行加减运算。利用补码的运算，用同一个运算结果，解决了有符号数与无符号数的加减法运算。


如果没有补码，很多运算都是无法同时实现的。


如-2 和（-8）的运算。如果仅用最高位的符号位区分正负来直接表示，而不用补码表示的话，

即10010（-2） 11000（-8，其中最高位为符号位，当两数相减后：

10010

11000

11010，（-10） 还向高位借了1



相加相加后：

10010

11000

01010 （10）

运算结果完全就是不是我们想要的结果，所以说如果在计算机内部直接的进行加减法运算，而不进行补码运算，其结果是错误的。

但是进行补码运运算的话即为

相加：

11110

11000

10110（-10的补码）

相减：

11110

11000

00110（6的补码）

然后求一次补码后。其运算结果完全正确。但是不得不深思为什么会对呢？为什么补码会有这么大的作用呢？

我是这样理解的。有这样一个类似钟表的圆盘，将其等间隔的刻256个刻度（以8位二进制数的加减法说明）
![](/assets/asm-10.jpg)

以顺时针为正（1,2,3,4,5,6,7，，，，，，64，，，，128，，，，192，，），逆时针为负（-1,-2。。。。-64。。。。-128。。。），0为起始点开始标注各点的值（图中只标注了几个）。

现在我们再把每个正数转化成其对应的二进制数即为：

0000 0000

0000 0001

0000 0010

...

...

...

1111 1100(252)

1111 1101(253)

1111 1110(254)

1111 1111(255)


就这么多，256呢？


1 0000 0000(256)


因为1进位了，只有8位，所以0和256为同一个刻度。


现在再说一下补码的问题。


我们发现，按照圆盘逆时针，刻的负数所在位置对应的正数的二进制，即为其对应的补码。


这时，可以这样理解在补码的世界里正负数是这样标注的，顺时针数一个刻度，为1，两个刻度为2。。。。逆时针为-1，-2，-3。。。


表示仍用刻在其上的二进制数表示。然后，就得到了计算机中的补码。


因为，8位二进制数只能表示256独立的数，所以用其表示范围为   -128 到 127。


找到每个数所在的位置后，结合时钟原理，就很容易明白，为什么补码能做加减运算而不出错了。

例如上面的-2,和-8的问题，

-2 对应为 1111 1110

-8 对应为 1111 1000


用-2 减去-8，就相当于把指向-2的那个时钟指针，沿逆时针方向转动了，1111 1000（248）个刻度指向了，6这个刻度，正好这个刻度的补码，就为其


本身。用同样的方法加就是往顺时针转了248个刻度正好是（-10的补码这个刻度）。


用钟表的方法很容找到一个负的128到0所对应的补码。即：先找到对应的正数，然后这个和这个正数沿竖直轴对称的左半圆盘上的数即是。



恩，我想了想，写的真是太烂了，不写了！